---
title: c++Constructor
date: 2016-10-15 00:15:42
tags:
---
`le 15 Oct`

### 引用
下面的写法定义了一个引用，并将其初始化为引用某个变量。
类型名 & 引用名 = 某变量名;
`int & r = n;`
- 定义引用时一定要将其初始化成引用某个变量。引用只能引用变量，不能引用常量和表达式。
例子：
```c++
void swap( int & a, int & b){
     int tmp;
     tmp = a; a = b; b = tmp;
}

int n1, n2;
swap(n1,n2) ; // n1,n2的值被交换
```

### 一般构造函数
- 如果创建一个类你没有写任何构造函数,则系统会自动生成默认的无参构造函数，函数为空，什么都不做
- 只要你写了一个下面的某一种构造函数，系统就不会再自动生成这样一个默认的构造函数，如果希望有一个这样的无参构造函数，则需要自己显示地写出来
- 一般构造函数可以有各种参数形式,一个类可以有多个一般构造函数，前提是参数的个数或者类型不同（基于c++的重载函数原理）
例如：你还可以写一个 Complex( int num)的构造函数出来
创建对象时根据传入的参数不同调用不同的构造函数
```c++
    Complex(double real, double imag)

    {

         m_real = real;

         m_imag = imag;
     }
```

### 拷贝构造函数(复制构造函数()
- 复制构造函数参数为类对象本身的引用，用于根据一个已存在的对象复制出一个新的该类的对象，一般在函数中会将已存在对象的数据成员的值复制一份到新创建的对象中
- 若没有显示的写复制构造函数，则系统会默认创建一个复制构造函数，但当类中有指针成员时，由系统默认创建该复制构造函数会存在风险，具体原因请查询有关 “浅拷贝” 、“深拷贝”的文章论述
```c++
    Complex(const Complex & c)
    {
        // 将对象c中的数据成员值复制过来
        m_real = c.m_real;
        m_img  = c.m_img;
    }
```

###  类型转换构造函数
- 根据一个指定的类型的对象创建一个本类的对象
例如：下面将根据一个double类型的对象创建了一个Complex对象
```c++
    Complex::Complex(double r)
    {
        m_real = r;
        m_imag = 0.0;
    }
```

### 派生类的构造函数

- 派生类拥有基类的全部成员函数和成员变
量，不论是private、protected、public。在派生类的各个成员函数中，不能访问
基类中的private成员。
- 派生类对象的体积，等于基类对象的体积，再加上派
生类对象自己的成员变量的体积。在派生类对象中，包
含着基类对象，而且基类对象的存储位置位于派生类对
象新增的成员变量之前。

- 执行基类构造函数前先执行派生类构造函数
```c++
class Skill { public:
Skill(int n) { } };

class FlyBug: public Bug { int nWings;
Skill sk1, sk2; public:
FlyBug(int legs, int color, int wings); };

FlyBug::FlyBug( int legs, int color, int wings): Bug(legs, color), sk1(5), sk2(color) {
nWings = wings; 
Bug::function();//派生类内部调用其基类函数
}
```

- 派生类调用基类成员
```c++
FlyBug a; 
a.function();// 本类函数
a.Bug::function();//基类函数

```

### 匿名对象

匿名对象可以理解为是一个临时对象，一般系统自动生成的，如你的函数返回一个对象，这个对象在返回时会生成一个临时对象。

总结：如果生成的匿名对象在外部有对象等待被其实例化，此匿名对象的生命周期就变成了外部对象的生命周期；
如果生成的匿名对象在外面没有对象等待被其实例化，此匿名对象将会生成之后，立马被析构。

```c++
class Cat
{
public:
    Cat()
    {
        cout<<"Cat类 无参构造函数"<<endl;
    }

    Cat(Const Cat& obj)
    {
        cout<<"Cat类 拷贝构造函数"<<endl;
    }

    ~Cat()
    {
        cout<<"Cat类 析构函数 "<<endl;
    }

};

void playStage() //一个舞台，展示对象的生命周期
{
    Cat();             /*在执行此代码时，利用无参构造函数生成了一个匿名Cat类对象；执行完此行代码，
                            因为外部没有接此匿名对象的变量，此匿名又被析构了*/
    Cat cc = Cat();    /*在执行此代码时，利用无参构造函数生成了一个匿名Cat类对象；然后将此匿名变
                            成了cc这个实例对象，此匿名对象没有被析构。*/
    cout<<"cc 对象好没有被析构"<<endl;    
}

int main()
{
    playStage();
    system("pause");
    return 0;
}
```
输出
```
Cat类 无参构造函数
Cat类 析构函数
Cat类 无参构造函数
cc 对象好没有被析构
Cat类 析构函数
```
说明：
1、在执行playStage( )函数中的Cat( )时，生成了一个匿名对象，执行完Cat( )代码后，此匿名对象就此
消失。这就是匿名对象的生命周期。
2、在执行playStage( )函数中Cat cc = Cat();时，首先生成了一个匿名对象，因为外部有cc对象在等待被
实例化，然后将此匿名对象变为了cc对象，其生命周期就变成了cc对象的生命周期。
